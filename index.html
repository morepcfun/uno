<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>UNO Card Game Online</title>
<meta name="description" content="Enjoy a classic game of Uno with two AI opponents right in your browser, completely free and without ads!">
<meta name="author" content="Johnny Heggelund">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
:root {
--card-height: 15vmin;
--card-width: calc(var(--card-height) * 0.7);
--border-radius: 1.5vmin;
--font-size-base: 2vmin;
}
body {
background-color: #121212;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
display: flex;
justify-content: center;
align-items: center;
height: 100vh;
margin: 0;
overflow: hidden;
}
.game-window {
width: 180vmin;
height: 90vmin;
max-width: 98vw;
max-height: 98vh;
aspect-ratio: 2 / 1;
background-color: #2c2c2c;
border-radius: var(--border-radius);
box-shadow: 0 1vmin 3vmin rgba(0, 0, 0, 0.5);
display: grid;
grid-template-columns: 1fr 7fr 1fr;
grid-template-rows: 1fr 1fr;
padding: 2vmin;
box-sizing: border-box;
position: relative;
opacity: 0.96;
}
.player-hand {
display: flex;
justify-content: center;
align-items: center;
padding: 1vmin;
}
#ai-player-1-hand {
grid-column: 1 / 2;
grid-row: 1 / 3;
flex-direction: column;
}
#ai-player-2-hand {
grid-column: 3 / 4;
grid-row: 1 / 3;
flex-direction: column;
}
.human-player {
grid-column: 2 / 3;
grid-row: 2 / 3;
background: rgba(0, 0, 0, 0.2);
border-radius: calc(var(--border-radius) * 0.75);
overflow-x: auto;
overflow-y: hidden;
}
.center-area {
grid-column: 2 / 3;
grid-row: 1 / 2;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
gap: 1.5vmin;
}
.deck-pile-container {
display: flex;
gap: 3vmin;
}
.game-status {
color: #fff;
font-size: calc(var(--font-size-base) * 1.2);
font-weight: bold;
padding: 1vmin 2vmin;
background-color: rgba(0, 0, 0, 0.3);
border-radius: 1vmin;
text-align: center;
min-height: 3.5vmin;
}
.card {
width: var(--card-width);
height: var(--card-height);
border-radius: calc(var(--border-radius) * 0.5);
border: 0.3vmin solid #fff;
display: flex;
justify-content: center;
align-items: center;
font-size: calc(var(--font-size-base) * 2);
font-weight: bold;
color: white;
box-shadow: 0 0.4vmin 1vmin rgba(0, 0, 0, 0.4);
position: relative;
transition: transform 0.2s ease, box-shadow 0.2s ease;
flex-shrink: 0;
}
.player-hand .card {
margin: -9vmin 0;
}
.human-player .card {
margin: 0 -2.1vmin;
}
.human-player .card.playable:hover {
transform: translateY(-2vmin) scale(1.05);
z-index: 10;
box-shadow: 0 1vmin 2.5vmin rgba(255, 255, 100, 0.6);
cursor: pointer;
}
.card.unplayable {
box-shadow: none;
filter: brightness(0.7);
}
.card.back {
background: #001d00 url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPjxwYXRoIGQ9Ik0wIDBoMnYySDB6TTIgMmgydjJIMnoiIGZpbGw9IiMzYTM3NDIiLz48L3N2Zz4=') no-repeat center center;
background-size: 90%;
border: 0.3vmin solid #555;
}
#deck.can-draw:hover {
cursor: pointer;
transform: scale(1.05);
box-shadow: 0 1vmin 2.5vmin rgba(100, 255, 100, 0.5);
}
.card .inner-symbol {
background-color: white;
width: calc(var(--card-width) * 0.7);
height: calc(var(--card-width) * 0.7);
border-radius: 50%;
display: flex;
justify-content: center;
align-items: center;
color: black;
font-size: 0.8em;
font-style: italic;
font-weight: bolder;
transform: rotate(-15deg);
}
.card[data-color="red"] {
background-color: #ff5555;
}
.card[data-color="yellow"] {
background-color: #ffaa00;
}
.card[data-color="green"] {
background-color: #55aa55;
}
.card[data-color="blue"] {
background-color: #5555ff;
}
.card[data-color="wild"] {
background: radial-gradient(circle, #ff5555 25%, #ffaa00 25%, #ffaa00 50%, #55aa55 50%, #55aa55 75%, #5555ff 75%);
}
.modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: none;
justify-content: center;
align-items: center;
z-index: 200;
}
.modal-content {
background-color: #2c2c2c;
color: #fff;
padding: 3vmin;
border-radius: var(--border-radius);
max-width: 90vmin;
width: 90%;
position: relative;
box-shadow: 0 0.5vmin 2.5vmin rgba(0, 0, 0, 0.5);
line-height: 1.6;
font-size: calc(var(--font-size-base) * 1.1);
}
.rules-btn {
background-color: DarkGreen;
color: LightGreen;
padding: 0.8vmin 1.5vmin;
border: none;
border-radius: 0.5vmin;
cursor: pointer;
font-size: calc(var(--font-size-base) * 1.4);
font-weight: bold;
transition: background-color 0.2s;
}
.rules-btn:hover {
background-color: #45a049;
}
.close-btn {
position: absolute;
top: 1vmin;
right: 2vmin;
font-size: calc(var(--font-size-base) * 2.5);
color: #fff;
cursor: pointer;
transition: transform 0.2s;
}
.close-btn:hover {
transform: scale(1.2);
}
.modal-content h2,
.modal-content h3 {
color: #4CAF50;
border-bottom: 2px solid #444;
padding-bottom: 5px;
margin-top: 15px;
}
.modal-content ul {
list-style-type: none;
padding: 0;
}
.modal-content li {
background: rgba(0, 0, 0, 0.2);
margin: 5px 0;
padding: 10px;
border-radius: 5px;
border-left: 4px solid #4CAF50;
}
.color-picker {
display: flex;
gap: 2vmin;
padding: 2vmin;
background: #3e3e3e;
border-radius: var(--border-radius);
}
.color-option {
width: 12vmin;
height: 12vmin;
border-radius: 50%;
cursor: pointer;
border: 0.5vmin solid white;
transition: transform 0.2s, box-shadow 0.2s;
}
.color-option:hover {
transform: scale(1.1);
box-shadow: 0 0 2vmin #fff;
}
.color-option[data-color="red"] {
background-color: #ff5555;
}
.color-option[data-color="yellow"] {
background-color: #ffaa00;
}
.color-option[data-color="green"] {
background-color: #55aa55;
}
.color-option[data-color="blue"] {
background-color: #5555ff;
}
.game-over-modal {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 100;
display: none;
flex-direction: column;
justify-content: center;
align-items: center;
color: white;
font-size: 5vmin;
text-align: center;
}
.game-over-modal h2 {
margin: 0;
}
.game-over-modal button {
margin-top: 2vmin;
padding: 1vmin 2vmin;
font-size: 2vmin;
}
</style>
</head>
<body>
<div id="game-window" class="game-window">
<div class="player-hand" id="ai-player-1-hand"></div>
<div class="center-area" style="color: white;">
<button id="rules-btn" class="rules-btn">Rules</button>
<br>
<div id="game-status" class="game-status"></div>
<div class="deck-pile-container">
<div class="card back" id="deck"></div>
<div class="card" id="discard-pile"></div>
</div>
</div>
<div class="player-hand" id="ai-player-2-hand"></div>
<div class="player-hand human-player" id="human-player-hand"></div>
<div id="game-over-modal" class="game-over-modal">
<h2 id="winner-message"></h2>
<button id="play-again-btn">Play Again</button>
</div>
</div>
<div id="rules-modal" class="modal-overlay">
<div class="modal-content">
<span id="close-btn" class="close-btn">&times;</span>
<h2 id="rules-title"></h2>
<p><strong id="rules-goal-title"></strong> <span id="rules-goal-text"></span></p>
<h3 id="rules-how-to-title"></h3>
<p id="rules-how-to-text"></p>
<h3 id="rules-special-title"></h3>
<ul id="rules-special-list">
<li id="rules-skip"></li>
<li id="rules-reverse"></li>
<li id="rules-draw2"></li>
<li id="rules-wild"></li>
<li id="rules-wild4"></li>
</ul>
</div>
</div>
<div id="color-picker-modal" class="modal-overlay">
<div class="color-picker">
<div class="color-option" data-color="red"></div>
<div class="color-option" data-color="yellow"></div>
<div class="color-option" data-color="green"></div>
<div class="color-option" data-color="blue"></div>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const lang = {
rules: "Rules",
welcome: "Welcome to UNO!",
yourTurn: "Your turn.",
playerTurn: "Player X's turn.",
aiPlaysCard: "Player X plays a card...",
aiDrawsCard: "Player X is drawing a card.",
aiPlaysDrawn: "Player X played the card they drew!",
aiCouldNotPlay: "Player X couldn't play.",
aiChoseColor: "Player X chose the color Y.",
youDrawCard: "You are drawing a card...",
youPlayDrawn: "You drew a playable card and played it!",
cardCannotBePlayed: "The card cannot be played. Next turn.",
invalidMove: "Invalid move. Card must match color or symbol.",
hasPlayableCard: "You have a playable card. You cannot draw.",
deckEmpty: "The deck is empty!",
shuffling: "Shuffling discard pile into the deck.",
playerSkipped: "Player X was skipped!",
directionReversed: "Play direction reversed!",
playerDrawsTwo: "Player X must draw 2 cards!",
playerDrawsFour: "Player X must draw 4 cards!",
playerHasUno: "Player X has UNO!",
youHaveUno: "You have UNO!",
playerWon: "Player X won the game! Congratulations! üèÜ",
youWon: "You won the game! Congratulations! üèÜ",
gameStarting: "The game is starting...",
gameStarted: "The game has started!",
startWithSkip: "Game starts with a Skip! Player X's turn.",
startWithReverse: "Game starts with a Reverse! Player X's turn.",
startWithDraw2: "Game starts with a Draw 2! Player X must draw.",
rulesTitle: "UNO Rules",
rulesGoalTitle: "Goal:",
rulesGoalText: "Be the first player to get rid of all your cards.",
rulesHowToTitle: "How to Play",
rulesHowToText: "You can play a card from your hand if it matches the color, number, or symbol of the card on top of the discard pile. If you can't play a card, you must draw one from the deck. Good luck!",
rulesSpecialTitle: "Special Cards",
rulesSkip: "<strong>Skip (üö´):</strong> The next player loses their turn.",
rulesReverse: "<strong>Reverse (üîÑ):</strong> The direction of play reverses.",
rulesDraw2: "<strong>Draw Two (+2):</strong> The next player draws two cards and loses their turn.",
rulesWild: "<strong>Wild (W):</strong> Can be played on any card. The player who lays it down chooses the next color.",
rulesWild4: "<strong>Wild + Draw Four (W+4):</strong> Can only be played if you have no other playable cards. The player chooses the next color, and the next player draws four cards and loses their turn.",
colors: { 'red': 'Red', 'yellow': 'Yellow', 'green': 'Green', 'blue': 'Blue' }
};
const SUITS = ['red', 'yellow', 'green', 'blue'];
const VALUES = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
const WILD_VALUES = ['wild', 'wild4'];
const NUM_PLAYERS = 3;
const HUMAN_PLAYER_INDEX = 0;
let deck = [];
let players = [];
let discardPile = [];
let currentPlayerIndex = 0;
let gameDirection = 1;
let isProcessingTurn = false;
const humanPlayerHandEl = document.getElementById('human-player-hand');
const aiPlayerHandElements = [
document.getElementById('ai-player-1-hand'),
document.getElementById('ai-player-2-hand')
];
const discardPileEl = document.getElementById('discard-pile');
const deckEl = document.getElementById('deck');
const gameStatusEl = document.getElementById('game-status');
const rulesBtn = document.getElementById('rules-btn');
const rulesModal = document.getElementById('rules-modal');
const closeBtn = document.getElementById('close-btn');
const colorPickerModal = document.getElementById('color-picker-modal');
const gameOverModal = document.getElementById('game-over-modal');
const winnerMessageEl = document.getElementById('winner-message');
const playAgainBtn = document.getElementById('play-again-btn');
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
function updateStaticUIText() {
document.title = "UNO";
rulesBtn.textContent = lang.rules;
gameStatusEl.textContent = lang.welcome;
document.getElementById('rules-title').textContent = lang.rulesTitle;
document.getElementById('rules-goal-title').textContent = lang.rulesGoalTitle;
document.getElementById('rules-goal-text').textContent = lang.rulesGoalText;
document.getElementById('rules-how-to-title').textContent = lang.rulesHowToTitle;
document.getElementById('rules-how-to-text').textContent = lang.rulesHowToText;
document.getElementById('rules-special-title').textContent = lang.rulesSpecialTitle;
document.getElementById('rules-skip').innerHTML = lang.rulesSkip;
document.getElementById('rules-reverse').innerHTML = lang.rulesReverse;
document.getElementById('rules-draw2').innerHTML = lang.rulesDraw2;
document.getElementById('rules-wild').innerHTML = lang.rulesWild;
document.getElementById('rules-wild4').innerHTML = lang.rulesWild4;
}
function getCardDisplayValue(card) {
switch (card.value) {
case 'skip': return 'üö´';
case 'reverse': return 'üîÑ';
case 'draw2': return '+2';
case 'wild': return 'W';
case 'wild4': return 'W+4';
default: return card.value.toUpperCase();
}
}
function isValidPlay(card, topCard) {
if (!topCard) return false;
if (card.suit === 'wild') {
if (card.value === 'wild4') {
const playerHand = players[currentPlayerIndex];
const hasMatchingColorCard = playerHand.some(c => c.suit !== 'wild' && c.suit === topCard.suit);
return !hasMatchingColorCard;
}
return true;
}
if (card.suit === topCard.suit) {
return true;
}
if (card.value === topCard.value) {
return true;
}
return false;
}
function createDeck() {
const newDeck = [];
SUITS.forEach(suit => {
VALUES.forEach(value => {
newDeck.push({ suit, value, originalSuit: suit });
if (value !== '0') {
newDeck.push({ suit, value, originalSuit: suit });
}
});
});
WILD_VALUES.forEach(value => {
for (let i = 0; i < 4; i++) {
newDeck.push({ suit: 'wild', value, originalSuit: 'wild' });
}
});
return newDeck;
}
function shuffleDeck(deck) {
for (let i = deck.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[deck[i], deck[j]] = [deck[j], deck[i]];
}
}
function renderCard(card) {
const cardElement = document.createElement('div');
cardElement.className = 'card';
cardElement.dataset.color = card.suit;
const displayValue = getCardDisplayValue(card);
cardElement.innerHTML = `<div class="inner-symbol">${displayValue}</div>`;
return cardElement;
}
function updateAllUI() {
renderPlayerHands();
renderDiscardPile();
highlightPlayableCards();
}
function renderPlayerHands() {
humanPlayerHandEl.innerHTML = '';
players[HUMAN_PLAYER_INDEX].forEach(card => {
const cardElement = renderCard(card);
cardElement.addEventListener('click', () => onPlayerCardClick(card));
humanPlayerHandEl.appendChild(cardElement);
});
for (let i = 1; i < NUM_PLAYERS; i++) {
const aiHandEl = aiPlayerHandElements[i - 1];
aiHandEl.innerHTML = '';
players[i].forEach(() => {
const cardElement = document.createElement('div');
cardElement.className = 'card back';
aiHandEl.appendChild(cardElement);
});
}
}
function renderDiscardPile() {
discardPileEl.innerHTML = '';
const topCard = discardPile[discardPile.length - 1];
if (topCard) {
discardPileEl.className = 'card';
discardPileEl.dataset.color = topCard.suit;
discardPileEl.innerHTML = `<div class="inner-symbol">${getCardDisplayValue(topCard)}</div>`;
} else {
discardPileEl.className = 'card';
}
}
function highlightPlayableCards() {
const topCard = discardPile[discardPile.length - 1];
if (!topCard) return;
const humanCards = humanPlayerHandEl.children;
for (let i = 0; i < humanCards.length; i++) {
const card = players[HUMAN_PLAYER_INDEX][i];
const cardEl = humanCards[i];
if (currentPlayerIndex === HUMAN_PLAYER_INDEX && isValidPlay(card, topCard)) {
cardEl.classList.add('playable');
cardEl.classList.remove('unplayable');
} else {
cardEl.classList.add('unplayable');
cardEl.classList.remove('playable');
}
}
if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
deckEl.classList.add('can-draw');
} else {
deckEl.classList.remove('can-draw');
}
}
function updateStatus(message, vars = {}) {
let finalMessage = message;
if (vars.playerIndex !== undefined) {
finalMessage = finalMessage.replace('X', vars.playerIndex + 1);
}
if (vars.color) {
finalMessage = finalMessage.replace('Y', lang.colors[vars.color]);
}
gameStatusEl.textContent = finalMessage;
}
async function onPlayerCardClick(card) {
if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;
const topCard = discardPile[discardPile.length - 1];
if (isValidPlay(card, topCard)) {
isProcessingTurn = true;
await playCard(card, HUMAN_PLAYER_INDEX);
} else {
updateStatus(lang.invalidMove);
await sleep(2000);
updateStatus(lang.yourTurn);
}
}
async function onDeckClick() {
if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;
const topCard = discardPile[discardPile.length - 1];
const hasPlayableCard = players[HUMAN_PLAYER_INDEX].some(card => isValidPlay(card, topCard));
if (hasPlayableCard) {
updateStatus(lang.hasPlayableCard);
return;
}
isProcessingTurn = true;
updateStatus(lang.youDrawCard);
await sleep(500);
const drawnCard = drawCard(HUMAN_PLAYER_INDEX);
updateAllUI();
await sleep(800);
if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
updateStatus(lang.youPlayDrawn);
await sleep(800);
await playCard(drawnCard, HUMAN_PLAYER_INDEX);
} else {
updateStatus(lang.cardCannotBePlayed);
await sleep(800);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
endTurn();
}
}
function drawCard(playerIndex) {
if (deck.length === 0) {
if (discardPile.length <= 1) {
updateStatus(lang.deckEmpty);
return null;
}
const topCard = discardPile.pop();
deck = discardPile.map(c => ({ ...c, suit: c.originalSuit }));
discardPile = [topCard];
shuffleDeck(deck);
updateStatus(lang.shuffling);
}
const card = deck.pop();
if (card) {
players[playerIndex].push(card);
}
return card;
}
async function playCard(card, playerIndex) {
const cardIndex = players[playerIndex].findIndex(c => c === card);
if (cardIndex === -1) {
isProcessingTurn = false;
return;
}
const [playedCard] = players[playerIndex].splice(cardIndex, 1);
if (playedCard.value === 'wild' || playedCard.value === 'wild4') {
const chosenColor = await handleWildCard(playerIndex);
playedCard.suit = chosenColor;
if (playerIndex !== HUMAN_PLAYER_INDEX) {
updateStatus(lang.aiChoseColor, { playerIndex, color: chosenColor });
await sleep(800);
}
}
discardPile.push(playedCard);
if (checkWinCondition(playerIndex)) return;
await handleSpecialCardEffects(playedCard, playerIndex);
}
async function handleSpecialCardEffects(card, playerIndex) {
let nextPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
let turnAdvanced = false;
updateAllUI();
await sleep(500);
switch (card.value) {
case 'skip':
updateStatus(lang.playerSkipped, { playerIndex: nextPlayerIndex });
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
case 'reverse':
gameDirection *= -1;
updateStatus(lang.directionReversed);
break;
case 'draw2':
updateStatus(lang.playerDrawsTwo, { playerIndex: nextPlayerIndex });
await sleep(500);
drawCard(nextPlayerIndex);
drawCard(nextPlayerIndex);
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
case 'wild4':
updateStatus(lang.playerDrawsFour, { playerIndex: nextPlayerIndex });
await sleep(500);
for (let i = 0; i < 4; i++) drawCard(nextPlayerIndex);
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
}
if (!turnAdvanced) {
currentPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
}
await sleep(800);
endTurn();
}
function endTurn() {
updateAllUI();
if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
updateStatus(lang.yourTurn);
isProcessingTurn = false;
} else {
updateStatus(lang.playerTurn, { playerIndex: currentPlayerIndex });
isProcessingTurn = true;
setTimeout(aiTurn, 1200);
}
}
function checkWinCondition(playerIndex) {
if (players[playerIndex].length === 0) {
const message = playerIndex === HUMAN_PLAYER_INDEX ? lang.youWon : lang.playerWon.replace('X', playerIndex + 1);
winnerMessageEl.textContent = message;
gameOverModal.style.display = 'flex';
return true;
}
if (players[playerIndex].length === 1) {
const message = playerIndex === HUMAN_PLAYER_INDEX ? lang.youHaveUno : lang.playerHasUno.replace('X', playerIndex + 1);
updateStatus(message);
}
return false;
}
function handleWildCard(playerIndex) {
if (playerIndex === HUMAN_PLAYER_INDEX) {
return new Promise(resolve => {
colorPickerModal.style.display = 'flex';
const onColorSelect = (e) => {
const chosenColor = e.target.dataset.color;
colorPickerModal.style.display = 'none';
colorPickerModal.querySelectorAll('.color-option').forEach(opt => opt.removeEventListener('click', onColorSelect));
resolve(chosenColor);
};
colorPickerModal.querySelectorAll('.color-option').forEach(opt => opt.addEventListener('click', onColorSelect, { once: true }));
});
} else {
const colorCounts = SUITS.reduce((acc, color) => ({ ...acc, [color]: 0 }), {});
players[playerIndex].forEach(c => {
if (c.suit !== 'wild') colorCounts[c.suit]++;
});
let maxCount = -1;
let dominantColor = SUITS[Math.floor(Math.random() * SUITS.length)];
for (const color in colorCounts) {
if (colorCounts[color] > maxCount) {
maxCount = colorCounts[color];
dominantColor = color;
}
}
return Promise.resolve(dominantColor);
}
}
async function aiTurn() {
const aiIndex = currentPlayerIndex;
const topCard = discardPile[discardPile.length - 1];
await sleep(500);
let playableCards = players[aiIndex].filter(card => isValidPlay(card, topCard));
if (playableCards.length > 0) {
let cardToPlay =
playableCards.find(c => ['wild4', 'draw2', 'skip', 'reverse'].includes(c.value)) ||
playableCards[Math.floor(Math.random() * playableCards.length)];
updateStatus(lang.aiPlaysCard, { playerIndex: aiIndex });
await sleep(800);
await playCard(cardToPlay, aiIndex);
} else {
updateStatus(lang.aiDrawsCard, { playerIndex: aiIndex });
await sleep(800);
const drawnCard = drawCard(aiIndex);
updateAllUI();
await sleep(500);
if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
updateStatus(lang.aiPlaysDrawn, { playerIndex: aiIndex });
await sleep(800);
await playCard(drawnCard, aiIndex);
} else {
updateStatus(lang.aiCouldNotPlay, { playerIndex: aiIndex });
await sleep(800);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
endTurn();
}
}
}
async function handleFirstCard(card) {
discardPile.push(card);
updateAllUI();
await sleep(500);
switch (card.value) {
case 'skip':
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
updateStatus(lang.startWithSkip, { playerIndex: currentPlayerIndex });
break;
case 'reverse':
gameDirection *= -1;
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
updateStatus(lang.startWithReverse, { playerIndex: currentPlayerIndex });
break;
case 'draw2':
updateStatus(lang.startWithDraw2, { playerIndex: currentPlayerIndex });
await sleep(500);
drawCard(currentPlayerIndex);
drawCard(currentPlayerIndex);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
break;
case 'wild':
const chosenColor = await handleWildCard(HUMAN_PLAYER_INDEX);
card.suit = chosenColor;
break;
}
await sleep(800);
endTurn();
}
async function startGame() {
gameOverModal.style.display = 'none';
deck = createDeck();
shuffleDeck(deck);
players = Array(NUM_PLAYERS).fill(0).map(() => []);
discardPile = [];
currentPlayerIndex = 0;
gameDirection = 1;
isProcessingTurn = true;
for (let i = 0; i < 7; i++) {
for (let j = 0; j < NUM_PLAYERS; j++) {
players[j].push(deck.pop());
}
}
let firstCard = deck.pop();
const specialActionValues = ['skip', 'reverse', 'draw2', 'wild4'];
while (specialActionValues.includes(firstCard.value)) {
deck.push(firstCard);
shuffleDeck(deck);
firstCard = deck.pop();
}
updateAllUI();
updateStatus(lang.gameStarting);
await sleep(1000);
await handleFirstCard(firstCard);
}
rulesBtn.addEventListener('click', () => { rulesModal.style.display = 'flex'; });
closeBtn.addEventListener('click', () => { rulesModal.style.display = 'none'; });
playAgainBtn.addEventListener('click', startGame);
window.addEventListener('click', (event) => {
if (event.target === rulesModal) {
rulesModal.style.display = 'none';
}
});
deckEl.addEventListener('click', onDeckClick);
updateStaticUIText();
startGame();
rulesModal.style.display = 'flex';
});
</script>
</body>
</html>