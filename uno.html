<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO Card Game</title>
    <style>
        :root {
            --card-height: 15vmin;
            --card-width: calc(var(--card-height) * 0.7);
            --border-radius: 1.5vmin;
            --font-size-base: 2vmin;
        }

        body {
            background-color: #121212;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-window {
            width: 180vmin;
            height: 90vmin;
            max-width: 98vw;
            max-height: 98vh;
            aspect-ratio: 2 / 1;
            background-color: #2c2c2c;
            border-radius: var(--border-radius);
            box-shadow: 0 1vmin 3vmin rgba(0, 0, 0, 0.5);
            display: grid;
            grid-template-columns: 1fr 7fr 1fr;
            grid-template-rows: 1fr 1fr;
            padding: 2vmin;
            box-sizing: border-box;
            position: relative;
            opacity: 0.96;
        }

        .player-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1vmin;
            border-radius: calc(var(--border-radius) * 0.75);
            transition: box-shadow 0.4s ease-in-out;
        }

        #ai-player-1-hand {
            grid-column: 1 / 2;
            grid-row: 1 / 3;
            flex-direction: column;
        }

        #ai-player-2-hand {
            grid-column: 3 / 4;
            grid-row: 1 / 3;
            flex-direction: column;
        }

        .human-player {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            background: rgba(0, 0, 0, 0.2);
            overflow-x: auto;
            overflow-y: hidden;
        }

        .active-player-indicator {
            box-shadow: 0 0 2vmin 0.5vmin gold;
        }

        .center-area {
            grid-column: 2 / 3;
            grid-row: 1 / 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1.5vmin;
        }

        .deck-pile-container {
            display: flex;
            gap: 3vmin;
        }

        .game-status {
            color: #fff;
            font-size: calc(var(--font-size-base) * 1.2);
            font-weight: bold;
            padding: 1vmin 2vmin;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 1vmin;
            text-align: center;
            min-height: 3.5vmin;
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: calc(var(--border-radius) * 0.5);
            border: 0.3vmin solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--font-size-base) * 2);
            font-weight: bold;
            color: white;
            box-shadow: 0 0.4vmin 1vmin rgba(0, 0, 0, 0.4);
            position: relative;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            flex-shrink: 0;
        }

        .player-hand .card {
            margin: -9vmin 0;
        }

        .human-player .card {
            margin: 0 -2.1vmin;
        }

        .human-player .card.playable:hover {
            transform: translateY(-2vmin) scale(1.05);
            z-index: 10;
            box-shadow: 0 1vmin 2.5vmin rgba(255, 255, 100, 0.6);
            cursor: pointer;
        }

        .card.unplayable {
            box-shadow: none;
            filter: brightness(0.7);
        }

        .card.back {
            background: #001d00 url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPjxwYXRoIGQ9Ik0wIDBoMnYySDB6TTIgMmgydjJIMnoiIGZpbGw9IiMzYTM3NDIiLz48L3N2Zz4=') no-repeat center center;
            background-size: 90%;
            border: 0.3vmin solid #555;
        }

        #deck.can-draw:hover {
            cursor: pointer;
            transform: scale(1.05);
            box-shadow: 0 1vmin 2.5vmin rgba(100, 255, 100, 0.5);
        }

        .card .inner-symbol {
            background-color: white;
            width: calc(var(--card-width) * 0.7);
            height: calc(var(--card-width) * 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: black;
            font-size: 0.8em;
            font-style: italic;
            font-weight: bolder;
            transform: rotate(-15deg);
        }

        .card[data-color="red"] { background-color: #ff5555; }
        .card[data-color="yellow"] { background-color: #ffaa00; }
        .card[data-color="green"] { background-color: #55aa55; }
        .card[data-color="blue"] { background-color: #5555ff; }
        .card[data-color="wild"] {
            background: radial-gradient(circle, #ff5555 25%, #ffaa00 25%, #ffaa00 50%, #55aa55 50%, #55aa55 75%, #5555ff 75%);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .modal-content {
            background-color: #2c2c2c;
            color: #fff;
            padding: 3vmin;
            border-radius: var(--border-radius);
            max-width: 90vmin;
            width: 90%;
            position: relative;
            box-shadow: 0 0.5vmin 2.5vmin rgba(0, 0, 0, 0.5);
            line-height: 1.6;
            font-size: calc(var(--font-size-base) * 1.1);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-content h2,
        .modal-content h3 {
            color: #4CAF50;
            border-bottom: 2px solid #444;
            padding-bottom: 5px;
            margin-top: 15px;
        }

        .modal-content ul {
            list-style-type: none;
            padding: 0;
        }

        .modal-content li {
            background: rgba(0, 0, 0, 0.2);
            margin: 5px 0;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }

        .rules-btn {
            background-color: DarkGreen;
            color: LightGreen;
            padding: 0.8vmin 1.5vmin;
            border: none;
            border-radius: 0.5vmin;
            cursor: pointer;
            font-size: calc(var(--font-size-base) * 1.4);
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .rules-btn:hover { background-color: #45a049; }

        .close-btn {
            position: absolute;
            top: 1vmin;
            right: 2vmin;
            font-size: calc(var(--font-size-base) * 2.5);
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .close-btn:hover { transform: scale(1.2); }

        .color-picker {
            display: flex;
            gap: 2vmin;
            padding: 2vmin;
            background: #3e3e3e;
            border-radius: var(--border-radius);
        }

        .color-option {
            width: 12vmin;
            height: 12vmin;
            border-radius: 50%;
            cursor: pointer;
            border: 0.5vmin solid white;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 0 2vmin #fff;
        }

        .color-option[data-color="red"] { background-color: #ff5555; }
        .color-option[data-color="yellow"] { background-color: #ffaa00; }
        .color-option[data-color="green"] { background-color: #55aa55; }
        .color-option[data-color="blue"] { background-color: #5555ff; }

        .game-over-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 5vmin;
            text-align: center;
        }

        .game-over-modal h2 { margin: 0; }

        .game-over-modal button {
            margin-top: 2vmin;
            padding: 1vmin 2vmin;
            font-size: 2vmin;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="game-window" class="game-window">
        <div class="player-hand" id="ai-player-1-hand"></div>

        <div class="center-area">
            <button id="rules-btn" class="rules-btn"></button>
            <br>
            <div id="game-status" class="game-status"></div>
            <div class="deck-pile-container">
                <div class="card back" id="deck"></div>
                <div class="card" id="discard-pile"></div>
            </div>
        </div>

        <div class="player-hand" id="ai-player-2-hand"></div>
        <div class="player-hand human-player" id="human-player-hand"></div>

        <div id="game-over-modal" class="game-over-modal">
            <h2 id="winner-message"></h2>
            <button id="play-again-btn">Play Again</button>
        </div>
    </div>

    <div id="rules-modal" class="modal-overlay">
        <div class="modal-content">
            <span id="close-btn" class="close-btn">&times;</span>
            <h2 id="rules-title"></h2>
            <p><strong id="rules-goal-title"></strong> <span id="rules-goal-text"></span></p>
            <h3 id="rules-how-to-title"></h3>
            <p id="rules-how-to-text"></p>
            <h3 id="rules-special-title"></h3>
            <ul id="rules-special-list">
                <li id="rules-skip"></li>
                <li id="rules-reverse"></li>
                <li id="rules-draw2"></li>
                <li id="rules-wild"></li>
                <li id="rules-wild4"></li>
            </ul>
        </div>
    </div>

    <div id="color-picker-modal" class="modal-overlay">
        <div class="color-picker">
            <div class="color-option" data-color="red"></div>
            <div class="color-option" data-color="yellow"></div>
            <div class="color-option" data-color="green"></div>
            <div class="color-option" data-color="blue"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Game Text and Translations ---
            const uiText = {
                rules: "Rules",
                welcome: "Welcome to UNO!",
                yourTurn: "Your turn.",
                playerTurn: "Player {player}'s turn.",
                aiPlaysCard: "Player {player} is playing a card...",
                aiDrawsCard: "Player {player} is drawing a card.",
                aiPlayedDrawn: "Player {player} played the card they drew!",
                aiCouldNotPlay: "Player {player} couldn't play.",
                aiChoseColor: "Player {player} chose {color}.",
                youDrawCard: "You are drawing a card...",
                youPlayedDrawn: "You drew a playable card and played it!",
                cardCannotBePlayed: "Card can't be played. Next turn.",
                invalidMove: "Invalid move. Card must match color or value.",
                hasPlayableCard: "You have a playable card. You cannot draw.",
                deckEmpty: "The draw pile is empty!",
                shuffling: "Shuffling discard pile into a new draw pile.",
                playerSkipped: "Player {player} was skipped!",
                directionReversed: "Play direction has been reversed!",
                playerDrawsTwo: "Player {player} must draw 2 cards!",
                playerDrawsFour: "Player {player} must draw 4 cards!",
                playerHasUno: "Player {player} has UNO!",
                youHaveUno: "You have UNO!",
                playerWon: "Player {player} has won the game! Congratulations! 🏆",
                youWon: "You have won the game! Congratulations! 🏆",
                gameStarting: "The game is starting...",
                startWithSkip: "Game starts with a Skip! It's Player {player}'s turn.",
                startWithReverse: "Game starts with a Reverse! It's Player {player}'s turn.",
                startWithDraw2: "Game starts with a Draw 2! Player {player} must draw.",
                startWithWild: "Game starts with a Wild. Player {player} chooses the color.",
                rulesTitle: "UNO Rules",
                rulesGoalTitle: "Objective:",
                rulesGoalText: "Be the first player to get rid of all your cards.",
                rulesHowToTitle: "How to Play",
                rulesHowToText: "You can play a card from your hand if it matches the color, number, or symbol of the card on top of the discard pile. If you can't play, you must draw a card from the deck. Good luck!",
                rulesSpecialTitle: "Special Cards",
                rulesSkip: "<strong>Skip (🚫):</strong> The next player misses their turn.",
                rulesReverse: "<strong>Reverse (🔄):</strong> The direction of play is reversed.",
                rulesDraw2: "<strong>Draw Two (+2):</strong> The next player draws two cards and misses their turn.",
                rulesWild: "<strong>Wild (W):</strong> Can be played on any card. The player who lays it down chooses the next color.",
                rulesWild4: "<strong>Wild + Draw Four (W+4):</strong> Can only be played if you do not have another card in your hand that matches the color of the discard pile. The player chooses the next color, and the next player draws four cards and misses their turn.",
                colors: { 'red': 'Red', 'yellow': 'Yellow', 'green': 'Green', 'blue': 'Blue' }
            };

            // --- Game Configuration & Constants ---
            const SUITS = ['red', 'yellow', 'green', 'blue'];
            const VALUES = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
            const WILD_VALUES = ['wild', 'wild4'];
            const NUM_PLAYERS = 3;
            const HUMAN_PLAYER_INDEX = 0;

            // --- Game State Variables ---
            let deck = [];
            let players = [];
            let discardPile = [];
            let currentPlayerIndex = 0;
            let gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
            let isProcessingTurn = false;

            // --- DOM Element References ---
            const humanPlayerHandEl = document.getElementById('human-player-hand');
            const aiPlayerHandElements = [
                document.getElementById('ai-player-1-hand'),
                document.getElementById('ai-player-2-hand')
            ];
            const discardPileEl = document.getElementById('discard-pile');
            const deckEl = document.getElementById('deck');
            const gameStatusEl = document.getElementById('game-status');
            const rulesBtn = document.getElementById('rules-btn');
            const rulesModal = document.getElementById('rules-modal');
            const closeBtn = document.getElementById('close-btn');
            const colorPickerModal = document.getElementById('color-picker-modal');
            const gameOverModal = document.getElementById('game-over-modal');
            const winnerMessageEl = document.getElementById('winner-message');
            const playAgainBtn = document.getElementById('play-again-btn');

            // --- Utility Functions ---
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            function updateStaticUIText() {
                document.title = "UNO Card Game";
                rulesBtn.textContent = uiText.rules;
                gameStatusEl.textContent = uiText.welcome;
                document.getElementById('rules-title').textContent = uiText.rulesTitle;
                document.getElementById('rules-goal-title').textContent = uiText.rulesGoalTitle;
                document.getElementById('rules-goal-text').textContent = uiText.rulesGoalText;
                document.getElementById('rules-how-to-title').textContent = uiText.rulesHowToTitle;
                document.getElementById('rules-how-to-text').textContent = uiText.rulesHowToText;
                document.getElementById('rules-special-title').textContent = uiText.rulesSpecialTitle;
                document.getElementById('rules-skip').innerHTML = uiText.rulesSkip;
                document.getElementById('rules-reverse').innerHTML = uiText.rulesReverse;
                document.getElementById('rules-draw2').innerHTML = uiText.rulesDraw2;
                document.getElementById('rules-wild').innerHTML = uiText.rulesWild;
                document.getElementById('rules-wild4').innerHTML = uiText.rulesWild4;
            }

            function getCardDisplayValue(card) {
                switch (card.value) {
                    case 'skip': return '🚫';
                    case 'reverse': return '🔄';
                    case 'draw2': return '+2';
                    case 'wild': return 'W';
                    case 'wild4': return 'W+4';
                    default: return card.value.toUpperCase();
                }
            }

            function updateStatus(message, vars = {}) {
                let finalMessage = message;
                if (vars.player !== undefined) {
                    finalMessage = finalMessage.replace('{player}', vars.player + 1);
                }
                if (vars.color) {
                    finalMessage = finalMessage.replace('{color}', uiText.colors[vars.color]);
                }
                gameStatusEl.textContent = finalMessage;
            }

            // --- Game Logic ---
            function isValidPlay(card, topCard) {
                if (!topCard) return false;

                // Wild cards are special
                if (card.suit === 'wild') {
                    if (card.value === 'wild4') {
                        // Check if the player has any card that matches the top card's color.
                        // If they do, they cannot play the Wild Draw 4.
                        const playerHand = players[currentPlayerIndex];
                        const hasMatchingColorCard = playerHand.some(c => c.suit !== 'wild' && c.suit === topCard.suit);
                        return !hasMatchingColorCard;
                    }
                    return true; // Regular wild is always playable
                }

                // Standard play: match color or value
                return card.suit === topCard.suit || card.value === topCard.value;
            }

            function createDeck() {
                const newDeck = [];
                SUITS.forEach(suit => {
                    VALUES.forEach(value => {
                        newDeck.push({ suit, value, originalSuit: suit });
                        // Add a second copy of each card except 0
                        if (value !== '0') {
                            newDeck.push({ suit, value, originalSuit: suit });
                        }
                    });
                });
                WILD_VALUES.forEach(value => {
                    for (let i = 0; i < 4; i++) {
                        newDeck.push({ suit: 'wild', value, originalSuit: 'wild' });
                    }
                });
                return newDeck;
            }

            function shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            function drawCard(playerIndex) {
                if (deck.length === 0) {
                    if (discardPile.length <= 1) {
                        updateStatus(uiText.deckEmpty);
                        return null;
                    }
                    // Reshuffle the discard pile to form a new deck
                    updateStatus(uiText.shuffling);
                    const topCard = discardPile.pop();
                    // Reset wild cards to their original state before shuffling
                    deck = discardPile.map(c => ({ ...c, suit: c.originalSuit }));
                    discardPile = [topCard];
                    shuffleDeck(deck);
                }
                const card = deck.pop();
                if (card) {
                    players[playerIndex].push(card);
                }
                return card;
            }

            async function playCard(card, playerIndex) {
                const cardIndex = players[playerIndex].findIndex(c => c === card);
                if (cardIndex === -1) {
                    console.error("Card not found in player's hand.");
                    isProcessingTurn = false;
                    return;
                }

                const [playedCard] = players[playerIndex].splice(cardIndex, 1);

                if (playedCard.value === 'wild' || playedCard.value === 'wild4') {
                    const chosenColor = await handleWildCard(playerIndex);
                    playedCard.suit = chosenColor; // Temporarily change the card's suit
                    if (playerIndex !== HUMAN_PLAYER_INDEX) {
                        updateStatus(uiText.aiChoseColor, { player: playerIndex, color: chosenColor });
                        await sleep(800);
                    }
                }

                discardPile.push(playedCard);
                if (checkWinCondition(playerIndex)) return;

                // Handle UNO call
                if (players[playerIndex].length === 1) {
                    const message = playerIndex === HUMAN_PLAYER_INDEX ? uiText.youHaveUno : uiText.playerHasUno;
                    updateStatus(message, { player: playerIndex });
                    await sleep(1000);
                }

                await handleSpecialCardEffects(playedCard, playerIndex);
            }

            async function handleSpecialCardEffects(card, playerIndex) {
                let nextPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                let turnAdvanced = false;

                updateAllUI();
                await sleep(500);

                switch (card.value) {
                    case 'skip':
                        updateStatus(uiText.playerSkipped, { player: nextPlayerIndex });
                        currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                        turnAdvanced = true;
                        break;
                    case 'reverse':
                        gameDirection *= -1;
                        updateStatus(uiText.directionReversed);
                        // With 2 players, reverse acts like a skip
                        if (NUM_PLAYERS === 2) {
                            currentPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                            turnAdvanced = true;
                        }
                        break;
                    case 'draw2':
                        updateStatus(uiText.playerDrawsTwo, { player: nextPlayerIndex });
                        await sleep(500);
                        drawCard(nextPlayerIndex);
                        drawCard(nextPlayerIndex);
                        currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                        turnAdvanced = true;
                        break;
                    case 'wild4':
                        updateStatus(uiText.playerDrawsFour, { player: nextPlayerIndex });
                        await sleep(500);
                        for (let i = 0; i < 4; i++) drawCard(nextPlayerIndex);
                        currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                        turnAdvanced = true;
                        break;
                }

                if (!turnAdvanced) {
                    currentPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                }

                await sleep(800);
                endTurn();
            }

            function endTurn() {
                updateAllUI();
                if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
                    updateStatus(uiText.yourTurn);
                    isProcessingTurn = false;
                } else {
                    updateStatus(uiText.playerTurn, { player: currentPlayerIndex });
                    isProcessingTurn = true;
                    setTimeout(aiTurn, 1500);
                }
            }

            function checkWinCondition(playerIndex) {
                if (players[playerIndex].length === 0) {
                    const message = playerIndex === HUMAN_PLAYER_INDEX ? uiText.youWon : uiText.playerWon.replace('{player}', playerIndex + 1);
                    winnerMessageEl.textContent = message;
                    gameOverModal.style.display = 'flex';
                    return true;
                }
                return false;
            }

            function handleWildCard(playerIndex) {
                if (playerIndex === HUMAN_PLAYER_INDEX) {
                    return new Promise(resolve => {
                        colorPickerModal.style.display = 'flex';
                        const onColorSelect = (e) => {
                            const chosenColor = e.target.dataset.color;
                            if (chosenColor) {
                                colorPickerModal.style.display = 'none';
                                colorPickerModal.removeEventListener('click', onColorSelect);
                                resolve(chosenColor);
                            }
                        };
                        colorPickerModal.addEventListener('click', onColorSelect);
                    });
                } else {
                    // AI chooses the color it has the most of
                    const colorCounts = SUITS.reduce((acc, color) => ({ ...acc, [color]: 0 }), {});
                    players[playerIndex].forEach(c => {
                        if (c.suit !== 'wild') colorCounts[c.suit]++;
                    });

                    let maxCount = -1;
                    let dominantColor = SUITS[Math.floor(Math.random() * SUITS.length)]; // Default to random
                    for (const color in colorCounts) {
                        if (colorCounts[color] > maxCount) {
                            maxCount = colorCounts[color];
                            dominantColor = color;
                        }
                    }
                    return Promise.resolve(dominantColor);
                }
            }

            async function aiTurn() {
                const aiIndex = currentPlayerIndex;
                const topCard = discardPile[discardPile.length - 1];
                await sleep(500);

                let playableCards = players[aiIndex].filter(card => isValidPlay(card, topCard));

                if (playableCards.length > 0) {
                    // Simple AI: prioritize action cards, otherwise play a random card
                    let cardToPlay =
                        playableCards.find(c => ['wild4', 'draw2', 'skip', 'reverse'].includes(c.value)) ||
                        playableCards[Math.floor(Math.random() * playableCards.length)];

                    updateStatus(uiText.aiPlaysCard, { player: aiIndex });
                    await sleep(800);
                    await playCard(cardToPlay, aiIndex);
                } else {
                    updateStatus(uiText.aiDrawsCard, { player: aiIndex });
                    await sleep(800);
                    const drawnCard = drawCard(aiIndex);
                    updateAllUI();
                    await sleep(500);

                    if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
                        updateStatus(uiText.aiPlayedDrawn, { player: aiIndex });
                        await sleep(800);
                        await playCard(drawnCard, aiIndex);
                    } else {
                        updateStatus(uiText.aiCouldNotPlay, { player: aiIndex });
                        await sleep(800);
                        currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                        endTurn();
                    }
                }
            }

            // --- UI Rendering ---
            function renderCard(card) {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.dataset.color = card.suit;
                const displayValue = getCardDisplayValue(card);
                cardElement.innerHTML = `<div class="inner-symbol">${displayValue}</div>`;
                return cardElement;
            }

            function updateAllUI() {
                renderPlayerHands();
                renderDiscardPile();
                highlightPlayableCards();
                updateActivePlayerIndicator();
            }

            function renderPlayerHands() {
                // Render Human Player's Hand
                humanPlayerHandEl.innerHTML = '';
                players[HUMAN_PLAYER_INDEX].forEach(card => {
                    const cardElement = renderCard(card);
                    cardElement.addEventListener('click', () => onPlayerCardClick(card));
                    humanPlayerHandEl.appendChild(cardElement);
                });

                // Render AI Players' Hands (as card backs)
                for (let i = 1; i < NUM_PLAYERS; i++) {
                    const aiHandEl = aiPlayerHandElements[i - 1];
                    aiHandEl.innerHTML = '';
                    players[i].forEach(() => {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'card back';
                        aiHandEl.appendChild(cardElement);
                    });
                }
            }

            function renderDiscardPile() {
                discardPileEl.innerHTML = '';
                const topCard = discardPile[discardPile.length - 1];
                if (topCard) {
                    discardPileEl.className = 'card';
                    discardPileEl.dataset.color = topCard.suit;
                    discardPileEl.innerHTML = `<div class="inner-symbol">${getCardDisplayValue(topCard)}</div>`;
                } else {
                    discardPileEl.className = 'card'; // Reset to a blank card face
                }
            }

            function highlightPlayableCards() {
                const topCard = discardPile[discardPile.length - 1];
                if (!topCard) return;

                const humanCards = humanPlayerHandEl.children;
                for (let i = 0; i < humanCards.length; i++) {
                    const card = players[HUMAN_PLAYER_INDEX][i];
                    const cardEl = humanCards[i];
                    if (currentPlayerIndex === HUMAN_PLAYER_INDEX && isValidPlay(card, topCard)) {
                        cardEl.classList.add('playable');
                        cardEl.classList.remove('unplayable');
                    } else {
                        cardEl.classList.add('unplayable');
                        cardEl.classList.remove('playable');
                    }
                }

                deckEl.classList.toggle('can-draw', currentPlayerIndex === HUMAN_PLAYER_INDEX);
            }

            function updateActivePlayerIndicator() {
                humanPlayerHandEl.classList.remove('active-player-indicator');
                aiPlayerHandElements.forEach(el => el.classList.remove('active-player-indicator'));

                if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
                    humanPlayerHandEl.classList.add('active-player-indicator');
                } else {
                    // AI player indices are 1 and 2, but array indices are 0 and 1
                    aiPlayerHandElements[currentPlayerIndex - 1].classList.add('active-player-indicator');
                }
            }

            // --- Event Handlers ---
            async function onPlayerCardClick(card) {
                if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;

                const topCard = discardPile[discardPile.length - 1];
                if (isValidPlay(card, topCard)) {
                    isProcessingTurn = true;
                    await playCard(card, HUMAN_PLAYER_INDEX);
                } else {
                    updateStatus(uiText.invalidMove);
                    await sleep(2000);
                    updateStatus(uiText.yourTurn);
                }
            }

            async function onDeckClick() {
                if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;

                const topCard = discardPile[discardPile.length - 1];
                const hasPlayable = players[HUMAN_PLAYER_INDEX].some(card => isValidPlay(card, topCard));

                if (hasPlayable) {
                    updateStatus(uiText.hasPlayableCard);
                    return;
                }

                isProcessingTurn = true;
                updateStatus(uiText.youDrawCard);
                await sleep(500);

                const drawnCard = drawCard(HUMAN_PLAYER_INDEX);
                updateAllUI();
                await sleep(800);

                if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
                    updateStatus(uiText.youPlayedDrawn);
                    await sleep(800);
                    await playCard(drawnCard, HUMAN_PLAYER_INDEX);
                } else {
                    updateStatus(uiText.cardCannotBePlayed);
                    await sleep(800);
                    currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                    endTurn();
                }
            }

            // --- Game Initialization ---
            async function handleFirstCard(card) {
                discardPile.push(card);
                updateAllUI();
                await sleep(500);

                let startMessage = uiText.playerTurn;
                let messageVars = { player: currentPlayerIndex };

                switch (card.value) {
                    case 'skip':
                        startMessage = uiText.startWithSkip;
                        currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                        messageVars.player = currentPlayerIndex;
                        break;
                    case 'reverse':
                        startMessage = uiText.startWithReverse;
                        gameDirection *= -1;
                        currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                        messageVars.player = currentPlayerIndex;
                        break;
                    case 'draw2':
                        startMessage = uiText.startWithDraw2;
                        messageVars.player = currentPlayerIndex;
                        updateStatus(startMessage, messageVars);
                        await sleep(500);
                        drawCard(currentPlayerIndex);
                        drawCard(currentPlayerIndex);
                        currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
                        break;
                    case 'wild':
                        startMessage = uiText.startWithWild;
                        updateStatus(startMessage, messageVars);
                        const chosenColor = await handleWildCard(0); // Player 0 (human) chooses
                        card.suit = chosenColor;
                        break;
                }

                if (card.value !== 'draw2') {
                    updateStatus(startMessage, messageVars);
                }

                await sleep(1200);
                endTurn();
            }

            async function startGame() {
                gameOverModal.style.display = 'none';
                deck = createDeck();
                shuffleDeck(deck);

                players = Array(NUM_PLAYERS).fill(0).map(() => []);
                discardPile = [];
                currentPlayerIndex = 0;
                gameDirection = 1;
                isProcessingTurn = true;

                // Deal 7 cards to each player
                for (let i = 0; i < 7; i++) {
                    for (let j = 0; j < NUM_PLAYERS; j++) {
                        players[j].push(deck.pop());
                    }
                }

                // Draw the first card for the discard pile
                let firstCard = deck.pop();
                // Per official rules, a Wild Draw 4 cannot be the first card
                while (firstCard.value === 'wild4') {
                    deck.push(firstCard);
                    shuffleDeck(deck);
                    firstCard = deck.pop();
                }

                updateAllUI();
                updateStatus(uiText.gameStarting);
                await sleep(1000);

                await handleFirstCard(firstCard);
            }

            // --- Event Listeners ---
            rulesBtn.addEventListener('click', () => { rulesModal.style.display = 'flex'; });
            closeBtn.addEventListener('click', () => { rulesModal.style.display = 'none'; });
            playAgainBtn.addEventListener('click', startGame);
            deckEl.addEventListener('click', onDeckClick);
            window.addEventListener('click', (event) => {
                if (event.target === rulesModal) {
                    rulesModal.style.display = 'none';
                }
            });

            // --- Initial Setup ---
            updateStaticUIText();
            startGame();
        });
    </script>
</body>
</html>