<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Uno</title>
<meta name="author" content="Johnny Heggelund">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
:root {
--card-height: 15vmin;
--card-width: calc(var(--card-height) * 0.7);
--border-radius: 1.5vmin;
--font-size-base: 2vmin;
}
body {
background-color: #121212;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
display: flex;
justify-content: center;
align-items: center;
height: 100vh;
margin: 0;
overflow: hidden;
}
.game-window {
width: 180vmin;
height: 90vmin;
max-width: 98vw;
max-height: 98vh;
aspect-ratio: 2 / 1;
background-color: #2c2c2c;
border-radius: var(--border-radius);
box-shadow: 0 1vmin 3vmin rgba(0, 0, 0, 0.5);
display: grid;
grid-template-columns: 1fr 7fr 1fr;
grid-template-rows: 1fr 1fr;
padding: 2vmin;
box-sizing: border-box;
position: relative;
opacity: 0.96;
}
.player-hand {
display: flex;
justify-content: center;
align-items: center;
padding: 1vmin;
}
#ai-player-1-hand {
grid-column: 1 / 2;
grid-row: 1 / 3;
flex-direction: column;
}
#ai-player-2-hand {
grid-column: 3 / 4;
grid-row: 1 / 3;
flex-direction: column;
}
.human-player {
grid-column: 2 / 3;
grid-row: 2 / 3;
background: rgba(0, 0, 0, 0.2);
border-radius: calc(var(--border-radius) * 0.75);
overflow-x: auto;
overflow-y: hidden;
}
.center-area {
grid-column: 2 / 3;
grid-row: 1 / 2;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
gap: 1.5vmin;
}
.deck-pile-container {
display: flex;
gap: 3vmin;
}
.game-status {
color: #fff;
font-size: calc(var(--font-size-base) * 1.2);
font-weight: bold;
padding: 1vmin 2vmin;
background-color: rgba(0, 0, 0, 0.3);
border-radius: 1vmin;
text-align: center;
min-height: 3.5vmin;
}
.card {
width: var(--card-width);
height: var(--card-height);
border-radius: calc(var(--border-radius) * 0.5);
border: 0.3vmin solid #fff;
display: flex;
justify-content: center;
align-items: center;
font-size: calc(var(--font-size-base) * 2);
font-weight: bold;
color: white;
box-shadow: 0 0.4vmin 1vmin rgba(0, 0, 0, 0.4);
position: relative;
transition: transform 0.2s ease, box-shadow 0.2s ease;
flex-shrink: 0;
}
.player-hand .card {
margin: -9vmin 0;
}
.human-player .card {
margin: 0 -2.1vmin;
}
.human-player .card.playable:hover {
transform: translateY(-2vmin) scale(1.05);
z-index: 10;
box-shadow: 0 1vmin 2.5vmin rgba(255, 255, 100, 0.6);
cursor: pointer;
}
.card.unplayable {
box-shadow: none;
filter: brightness(0.7);
}
.card.back {
background: #001d00 url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPjxwYXRoIGQ9Ik0wIDBoMnYySDB6TTIgMmgydjJIMnoiIGZpbGw9IiMzYTM3NDIiLz48L3N2Zz4=') no-repeat center center;
background-size: 90%;
border: 0.3vmin solid #555;
}
#deck.can-draw:hover {
cursor: pointer;
transform: scale(1.05);
box-shadow: 0 1vmin 2.5vmin rgba(100, 255, 100, 0.5);
}
.card .inner-symbol {
background-color: white;
width: calc(var(--card-width) * 0.7);
height: calc(var(--card-width) * 0.7);
border-radius: 50%;
display: flex;
justify-content: center;
align-items: center;
color: black;
font-size: 0.8em;
font-style: italic;
font-weight: bolder;
transform: rotate(-15deg);
}
.card[data-color="red"] {
background-color: #ff5555;
}
.card[data-color="yellow"] {
background-color: #ffaa00;
}
.card[data-color="green"] {
background-color: #55aa55;
}
.card[data-color="blue"] {
background-color: #5555ff;
}
.card[data-color="wild"] {
background: radial-gradient(circle, #ff5555 25%, #ffaa00 25%, #ffaa00 50%, #55aa55 50%, #55aa55 75%, #5555ff 75%);
}
.modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: none;
justify-content: center;
align-items: center;
z-index: 200;
}
.modal-content {
background-color: #2c2c2c;
color: #fff;
padding: 3vmin;
border-radius: var(--border-radius);
max-width: 90vmin;
width: 90%;
position: relative;
box-shadow: 0 0.5vmin 2.5vmin rgba(0, 0, 0, 0.5);
line-height: 1.6;
font-size: calc(var(--font-size-base) * 1.1);
}
.rules-btn {
background-color: DarkGreen;
color: LightGreen;
padding: 0.8vmin 1.5vmin;
border: none;
border-radius: 0.5vmin;
cursor: pointer;
font-size: calc(var(--font-size-base) * 1.4);
font-weight: bold;
transition: background-color 0.2s;
}
.rules-btn:hover {
background-color: #45a049;
}
.close-btn {
position: absolute;
top: 1vmin;
right: 2vmin;
font-size: calc(var(--font-size-base) * 2.5);
color: #fff;
cursor: pointer;
transition: transform 0.2s;
}
.close-btn:hover {
transform: scale(1.2);
}
.modal-content h2,
.modal-content h3 {
color: #4CAF50;
border-bottom: 2px solid #444;
padding-bottom: 5px;
margin-top: 15px;
}
.modal-content ul {
list-style-type: none;
padding: 0;
}
.modal-content li {
background: rgba(0, 0, 0, 0.2);
margin: 5px 0;
padding: 10px;
border-radius: 5px;
border-left: 4px solid #4CAF50;
}
.color-picker {
display: flex;
gap: 2vmin;
padding: 2vmin;
background: #3e3e3e;
border-radius: var(--border-radius);
}
.color-option {
width: 12vmin;
height: 12vmin;
border-radius: 50%;
cursor: pointer;
border: 0.5vmin solid white;
transition: transform 0.2s, box-shadow 0.2s;
}
.color-option:hover {
transform: scale(1.1);
box-shadow: 0 0 2vmin #fff;
}
.color-option[data-color="red"] {
background-color: #ff5555;
}
.color-option[data-color="yellow"] {
background-color: #ffaa00;
}
.color-option[data-color="green"] {
background-color: #55aa55;
}
.color-option[data-color="blue"] {
background-color: #5555ff;
}
</style>
</head>
<body>
<div id="game-window" class="game-window">
<div class="player-hand" id="ai-player-1-hand"></div>
<div class="center-area" style="color: white;">
<button id="rules-btn" class="rules-btn">Rules</button>
<br>
<div id="game-status" class="game-status">Welcome to UNO!</div>
<div class="deck-pile-container">
<div class="card back" id="deck"></div>
<div class="card" id="discard-pile"></div>
</div>
</div>
<div class="player-hand" id="ai-player-2-hand"></div>
<div class="player-hand human-player" id="human-player-hand"></div>
</div>
<div id="rules-modal" class="modal-overlay">
<div class="modal-content">
<span id="close-btn" class="close-btn">&times;</span>
<h2>UNO Rules</h2>
<p><strong>Goal:</strong> Be the first player to get rid of all your cards.</p>
<h3>How to Play</h3>
<p>You can play a card from your hand if it matches the color, number, or symbol of the card on top of the
discard pile. If you can't play a card, you must draw one from the deck. Good luck!</p>
<h3>Special Cards</h3>
<ul>
<li><strong>Skip (S):</strong> Next player loses their turn.</li>
<li><strong>Reverse (R):</strong> The direction of play reverses.</li>
<li><strong>Draw Two (+2):</strong> Next player draws two cards and loses their turn.</li>
<li><strong>Wild (W):</strong> Can be played on any card. The player who plays it chooses the next
color.</li>
<li><strong>Wild Draw Four (W+4):</strong> Can only be played if you have no other playable cards. The
player chooses the next color, and the next player draws four cards and loses their turn.</li>
</ul>
</div>
</div>
<div id="color-picker-modal" class="modal-overlay">
<div class="color-picker">
<div class="color-option" data-color="red"></div>
<div class="color-option" data-color="yellow"></div>
<div class="color-option" data-color="green"></div>
<div class="color-option" data-color="blue"></div>
</div>
</div>
<script>
// STATS-FETCHER-START
fetch('https://www.chromebooker.com/stats/visitors.php', {
method: 'POST',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify({ page: window.location.href })
});
// STATS-FETCHER-END
document.addEventListener('DOMContentLoaded', () => {
const SUITS = ['red', 'yellow', 'green', 'blue'];
const VALUES = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
const WILD_VALUES = ['wild', 'wild4'];
const ENGLISH_COLORS = { 'red': 'Red', 'yellow': 'Yellow', 'green': 'Green', 'blue': 'Blue' };
const NUM_PLAYERS = 3;
const HUMAN_PLAYER_INDEX = 0;
let deck = [];
let players = [];
let discardPile = [];
let currentPlayerIndex = 0;
let gameDirection = 1;
let isProcessingTurn = false;
const humanPlayerHandEl = document.getElementById('human-player-hand');
const aiPlayerHandElements = [
document.getElementById('ai-player-1-hand'),
document.getElementById('ai-player-2-hand')
];
const discardPileEl = document.getElementById('discard-pile');
const deckEl = document.getElementById('deck');
const gameStatusEl = document.getElementById('game-status');
const rulesBtn = document.getElementById('rules-btn');
const rulesModal = document.getElementById('rules-modal');
const closeBtn = document.getElementById('close-btn');
const colorPickerModal = document.getElementById('color-picker-modal');
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
function getCardDisplayValue(card) {
switch (card.value) {
case 'skip': return 'H';
case 'reverse': return 'V';
case 'draw2': return '+2';
case 'wild': return 'V';
case 'wild4': return 'V+4';
default: return card.value.toUpperCase();
}
}
function isValidPlay(card, topCard) {
if (!topCard) return false;
if (card.suit === 'wild') {
if (card.value === 'wild4') {
const playerHand = players[currentPlayerIndex];
const hasMatchingColorCard = playerHand.some(c => c.suit === topCard.suit);
return !hasMatchingColorCard;
}
return true;
}
if (card.suit === topCard.suit) {
return true;
}
if (card.value === topCard.value) {
return true;
}
return false;
}
function createDeck() {
const newDeck = [];
SUITS.forEach(suit => {
VALUES.forEach(value => {
newDeck.push({ suit, value, originalSuit: suit });
if (value !== '0') {
newDeck.push({ suit, value, originalSuit: suit });
}
});
});
WILD_VALUES.forEach(value => {
for (let i = 0; i < 4; i++) {
newDeck.push({ suit: 'wild', value, originalSuit: 'wild' });
}
});
return newDeck;
}
function shuffleDeck(deck) {
for (let i = deck.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[deck[i], deck[j]] = [deck[j], deck[i]];
}
}
function renderCard(card) {
const cardElement = document.createElement('div');
cardElement.className = 'card';
cardElement.dataset.color = card.suit;
const displayValue = getCardDisplayValue(card);
cardElement.innerHTML = `<div class="inner-symbol">${displayValue}</div>`;
return cardElement;
}
function updateAllUI() {
renderPlayerHands();
renderDiscardPile();
highlightPlayableCards();
}
function renderPlayerHands() {
humanPlayerHandEl.innerHTML = '';
players[HUMAN_PLAYER_INDEX].forEach(card => {
const cardElement = renderCard(card);
cardElement.addEventListener('click', () => onPlayerCardClick(card));
humanPlayerHandEl.appendChild(cardElement);
});
for (let i = 1; i < NUM_PLAYERS; i++) {
const aiHandEl = aiPlayerHandElements[i - 1];
aiHandEl.innerHTML = '';
players[i].forEach(() => {
const cardElement = document.createElement('div');
cardElement.className = 'card back';
aiHandEl.appendChild(cardElement);
});
}
}
function renderDiscardPile() {
discardPileEl.innerHTML = '';
const topCard = discardPile[discardPile.length - 1];
if (topCard) {
discardPileEl.className = 'card';
discardPileEl.dataset.color = topCard.suit;
discardPileEl.innerHTML = `<div class="inner-symbol">${getCardDisplayValue(topCard)}</div>`;
} else {
discardPileEl.className = 'card';
}
}
function highlightPlayableCards() {
const topCard = discardPile[discardPile.length - 1];
if (!topCard) return;
const humanCards = humanPlayerHandEl.children;
for (let i = 0; i < humanCards.length; i++) {
const card = players[HUMAN_PLAYER_INDEX][i];
const cardEl = humanCards[i];
if (currentPlayerIndex === HUMAN_PLAYER_INDEX && isValidPlay(card, topCard)) {
cardEl.classList.add('playable');
cardEl.classList.remove('unplayable');
} else {
cardEl.classList.add('unplayable');
cardEl.classList.remove('playable');
}
}
if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
deckEl.classList.add('can-draw');
} else {
deckEl.classList.remove('can-draw');
}
}
function updateStatus(message) {
gameStatusEl.textContent = message;
}
async function onPlayerCardClick(card) {
if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;
const topCard = discardPile[discardPile.length - 1];
if (isValidPlay(card, topCard)) {
isProcessingTurn = true;
await playCard(card, HUMAN_PLAYER_INDEX);
} else {
updateStatus("Invalid move. The card must match color or symbol.");
await sleep(2000);
updateStatus(`Player ${currentPlayerIndex + 1}'s turn.`);
}
}
async function onDeckClick() {
if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;
const topCard = discardPile[discardPile.length - 1];
const hasPlayableCard = players[HUMAN_PLAYER_INDEX].some(card => isValidPlay(card, topCard));
if (hasPlayableCard) {
updateStatus("You have a playable card. You cannot draw.");
return;
}
isProcessingTurn = true;
updateStatus("You draw a card...");
await sleep(500);
const drawnCard = drawCard(HUMAN_PLAYER_INDEX);
updateAllUI();
await sleep(800);
if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
updateStatus("You drew a playable card and play it!");
await sleep(800);
await playCard(drawnCard, HUMAN_PLAYER_INDEX);
} else {
updateStatus("Card could not be played. Turn passes.");
await sleep(800);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
endTurn();
}
}
function drawCard(playerIndex) {
if (deck.length === 0) {
if (discardPile.length <= 1) {
updateStatus("The deck is out of cards!");
return null;
}
const topCard = discardPile.pop();
deck = discardPile.map(c => ({ ...c, suit: c.originalSuit }));
discardPile = [topCard];
shuffleDeck(deck);
updateStatus("Shuffling the discard pile into the deck.");
}
const card = deck.pop();
if (card) {
players[playerIndex].push(card);
}
return card;
}
async function playCard(card, playerIndex) {
const cardIndex = players[playerIndex].findIndex(c => c === card);
if (cardIndex === -1) {
isProcessingTurn = false;
return;
}
const [playedCard] = players[playerIndex].splice(cardIndex, 1);
if (playedCard.value === 'wild' || playedCard.value === 'wild4') {
const chosenColor = await handleWildCard(playerIndex);
playedCard.suit = chosenColor;
if (playerIndex !== HUMAN_PLAYER_INDEX) {
updateStatus(`Player ${playerIndex + 1} chose ${ENGLISH_COLORS[chosenColor]}.`);
await sleep(800);
}
}
discardPile.push(playedCard);
if (checkWinCondition(playerIndex)) return;
await handleSpecialCardEffects(playedCard, playerIndex);
}
async function handleSpecialCardEffects(card, playerIndex) {
let nextPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
let turnAdvanced = false;
updateAllUI();
await sleep(500);
switch (card.value) {
case 'skip':
updateStatus(`Player ${nextPlayerIndex + 1} is skipped!`);
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
case 'reverse':
gameDirection *= -1;
updateStatus("Direction of play reversed!");
break;
case 'draw2':
updateStatus(`Player ${nextPlayerIndex + 1} must draw 2 cards!`);
await sleep(500);
drawCard(nextPlayerIndex);
drawCard(nextPlayerIndex);
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
case 'wild4':
updateStatus(`Player ${nextPlayerIndex + 1} must draw 4 cards!`);
await sleep(500);
for (let i = 0; i < 4; i++) drawCard(nextPlayerIndex);
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
}
if (!turnAdvanced) {
currentPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
}
await sleep(800);
endTurn();
}
function endTurn() {
updateAllUI();
updateStatus(`Player ${currentPlayerIndex + 1}'s turn.`);
if (currentPlayerIndex !== HUMAN_PLAYER_INDEX) {
isProcessingTurn = true;
setTimeout(aiTurn, 1200);
} else {
isProcessingTurn = false;
}
}
function checkWinCondition(playerIndex) {
const playerName = playerIndex === HUMAN_PLAYER_INDEX ? "You" : `Player ${playerIndex + 1}`;
if (players[playerIndex].length === 0) {
setTimeout(() => {
alert(`${playerName} won the game! Congratulations! 🏆`);
startGame();
}, 500);
return true;
}
if (players[playerIndex].length === 1) {
updateStatus(`${playerName} has UNO!`);
}
return false;
}
function handleWildCard(playerIndex) {
if (playerIndex === HUMAN_PLAYER_INDEX) {
return new Promise(resolve => {
colorPickerModal.style.display = 'flex';
const onColorSelect = (e) => {
const chosenColor = e.target.dataset.color;
colorPickerModal.style.display = 'none';
colorPickerModal.querySelectorAll('.color-option').forEach(opt => opt.removeEventListener('click', onColorSelect));
resolve(chosenColor);
};
colorPickerModal.querySelectorAll('.color-option').forEach(opt => opt.addEventListener('click', onColorSelect, { once: true }));
});
} else {
const colorCounts = SUITS.reduce((acc, color) => ({ ...acc, [color]: 0 }), {});
players[playerIndex].forEach(c => {
if (c.suit !== 'wild') colorCounts[c.suit]++;
});
let maxCount = -1;
let dominantColor = SUITS[Math.floor(Math.random() * SUITS.length)];
for (const color in colorCounts) {
if (colorCounts[color] > maxCount) {
maxCount = colorCounts[color];
dominantColor = color;
}
}
return Promise.resolve(dominantColor);
}
}
async function aiTurn() {
const aiIndex = currentPlayerIndex;
const topCard = discardPile[discardPile.length - 1];
await sleep(500);
let playableCards = players[aiIndex].filter(card => isValidPlay(card, topCard));
if (playableCards.length > 0) {
let cardToPlay =
playableCards.find(c => ['wild4', 'draw2', 'skip', 'reverse'].includes(c.value)) ||
playableCards[Math.floor(Math.random() * playableCards.length)];
updateStatus(`Player ${aiIndex + 1} plays a card...`);
await sleep(800);
await playCard(cardToPlay, aiIndex);
} else {
updateStatus(`Player ${aiIndex + 1} draws a card.`);
await sleep(800);
const drawnCard = drawCard(aiIndex);
updateAllUI();
await sleep(500);
if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
updateStatus(`Player ${aiIndex + 1} plays the drawn card!`);
await sleep(800);
await playCard(drawnCard, aiIndex);
} else {
updateStatus(`Player ${aiIndex + 1} could not play.`);
await sleep(800);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
endTurn();
}
}
}
async function startGame() {
deck = createDeck();
shuffleDeck(deck);
players = Array(NUM_PLAYERS).fill(0).map(() => []);
discardPile = [];
currentPlayerIndex = 0;
gameDirection = 1;
isProcessingTurn = true;
for (let i = 0; i < 7; i++) {
for (let j = 0; j < NUM_PLAYERS; j++) {
players[j].push(deck.pop());
}
}
let firstCard = deck.pop();
while (firstCard.suit === 'wild') {
deck.push(firstCard);
shuffleDeck(deck);
firstCard = deck.pop();
}
discardPile.push(firstCard);
updateAllUI();
updateStatus("Game is starting...");
await sleep(1000);
let startMessage = `Game started! Player 1's turn.`;
let initialTurnHandled = false;
switch (firstCard.value) {
case 'skip':
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
startMessage = `Game starts with Skip! Player ${currentPlayerIndex + 1}'s turn.`;
initialTurnHandled = true;
break;
case 'reverse':
gameDirection *= -1;
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
startMessage = `Game starts with Reverse! Player ${currentPlayerIndex + 1}'s turn.`;
initialTurnHandled = true;
break;
case 'draw2':
startMessage = `Game starts with Draw 2! Player 1 must draw.`;
updateStatus(startMessage);
await sleep(800);
drawCard(0);
drawCard(0);
updateAllUI();
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
startMessage = `Player ${currentPlayerIndex + 1}'s turn.`;
initialTurnHandled = true;
break;
}
updateStatus(startMessage);
endTurn();
}
rulesBtn.addEventListener('click', () => { rulesModal.style.display = 'flex'; });
closeBtn.addEventListener('click', () => { rulesModal.style.display = 'none'; });
window.addEventListener('click', (event) => {
if (event.target === rulesModal) {
rulesModal.style.display = 'none';
}
});
deckEl.addEventListener('click', onDeckClick);
startGame();
rulesModal.style.display = 'flex';
});
</script>
</body>
</html>