<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>UNO Kortspill</title>
<link rel="icon" href="data:image/png;base64,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">

<style>
:root {
--card-height: 15vmin;
--card-width: calc(var(--card-height) * 0.7);
--border-radius: 1.5vmin;
--font-size-base: 2vmin;
}
body {
background-color: #121212;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
display: flex;
justify-content: center;
align-items: center;
height: 100vh;
margin: 0;
overflow: hidden;
}
.game-window {
width: 180vmin;
height: 90vmin;
max-width: 98vw;
max-height: 98vh;
aspect-ratio: 2 / 1;
background-color: #2c2c2c;
border-radius: var(--border-radius);
box-shadow: 0 1vmin 3vmin rgba(0, 0, 0, 0.5);
display: grid;
grid-template-columns: 1fr 7fr 1fr;
grid-template-rows: 1fr 1fr;
padding: 2vmin;
box-sizing: border-box;
position: relative;
opacity: 0.96;
}
.player-hand {
display: flex;
justify-content: center;
align-items: center;
padding: 1vmin;
border-radius: calc(var(--border-radius) * 0.75);
transition: box-shadow 0.4s ease-in-out;
}
#ai-player-1-hand {
grid-column: 1 / 2;
grid-row: 1 / 3;
flex-direction: column;
}
#ai-player-2-hand {
grid-column: 3 / 4;
grid-row: 1 / 3;
flex-direction: column;
}
.human-player {
grid-column: 2 / 3;
grid-row: 2 / 3;
background: rgba(0, 0, 0, 0.2);
overflow-x: auto;
overflow-y: hidden;
}
.active-player-indicator {
box-shadow: 0 0 2vmin 0.5vmin gold;
}
.center-area {
grid-column: 2 / 3;
grid-row: 1 / 2;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
gap: 1.5vmin;
}
.deck-pile-container {
display: flex;
gap: 3vmin;
}
.game-status {
color: #fff;
font-size: calc(var(--font-size-base) * 1.2);
font-weight: bold;
padding: 1vmin 2vmin;
background-color: rgba(0, 0, 0, 0.3);
border-radius: 1vmin;
text-align: center;
min-height: 3.5vmin;
}
.card {
width: var(--card-width);
height: var(--card-height);
border-radius: calc(var(--border-radius) * 0.5);
border: 0.3vmin solid #fff;
display: flex;
justify-content: center;
align-items: center;
font-size: calc(var(--font-size-base) * 2);
font-weight: bold;
color: white;
box-shadow: 0 0.4vmin 1vmin rgba(0, 0, 0, 0.4);
position: relative;
transition: transform 0.2s ease, box-shadow 0.2s ease;
flex-shrink: 0;
}
.player-hand .card {
margin: -9vmin 0;
}
.human-player .card {
margin: 0 -2.1vmin;
}
.human-player .card.playable:hover {
transform: translateY(-2vmin) scale(1.05);
z-index: 10;
box-shadow: 0 1vmin 2.5vmin rgba(255, 255, 100, 0.6);
cursor: pointer;
}
.card.unplayable {
box-shadow: none;
filter: brightness(0.7);
}
.card.back {
background: #001d00 url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPjxwYXRoIGQ9Ik0wIDBoMnYySDB6TTIgMmgydjJIMnoiIGZpbGw9IiMzYTM3NDIiLz48L3N2Zz4=') no-repeat center center;
background-size: 90%;
border: 0.3vmin solid #555;
}
#deck.can-draw:hover {
cursor: pointer;
transform: scale(1.05);
box-shadow: 0 1vmin 2.5vmin rgba(100, 255, 100, 0.5);
}
.card .inner-symbol {
background-color: white;
width: calc(var(--card-width) * 0.7);
height: calc(var(--card-width) * 0.7);
border-radius: 50%;
display: flex;
justify-content: center;
align-items: center;
color: black;
font-size: 0.8em;
font-style: italic;
font-weight: bolder;
transform: rotate(-15deg);
}
.card[data-color="red"] { background-color: #ff5555; }
.card[data-color="yellow"] { background-color: #ffaa00; }
.card[data-color="green"] { background-color: #55aa55; }
.card[data-color="blue"] { background-color: #5555ff; }
.card[data-color="wild"] {
background: radial-gradient(circle, #ff5555 25%, #ffaa00 25%, #ffaa00 50%, #55aa55 50%, #55aa55 75%, #5555ff 75%);
}
.modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: none;
justify-content: center;
align-items: center;
z-index: 200;
}
.modal-content {
background-color: #2c2c2c;
color: #fff;
padding: 3vmin;
border-radius: var(--border-radius);
max-width: 90vmin;
width: 90%;
position: relative;
box-shadow: 0 0.5vmin 2.5vmin rgba(0, 0, 0, 0.5);
line-height: 1.6;
font-size: calc(var(--font-size-base) * 1.1);
max-height: 90vh;
overflow-y: auto;
}
.rules-btn {
background-color: DarkGreen;
color: LightGreen;
padding: 0.8vmin 1.5vmin;
border: none;
border-radius: 0.5vmin;
cursor: pointer;
font-size: calc(var(--font-size-base) * 1.4);
font-weight: bold;
transition: background-color 0.2s;
}
.rules-btn:hover { background-color: #45a049; }
.close-btn {
position: absolute;
top: 1vmin;
right: 2vmin;
font-size: calc(var(--font-size-base) * 2.5);
color: #fff;
cursor: pointer;
transition: transform 0.2s;
}
.close-btn:hover { transform: scale(1.2); }
.modal-content h2, .modal-content h3 {
color: #4CAF50;
border-bottom: 2px solid #444;
padding-bottom: 5px;
margin-top: 15px;
}
.modal-content ul {
list-style-type: none;
padding: 0;
}
.modal-content li {
background: rgba(0, 0, 0, 0.2);
margin: 5px 0;
padding: 10px;
border-radius: 5px;
border-left: 4px solid #4CAF50;
}
.color-picker {
display: flex;
gap: 2vmin;
padding: 2vmin;
background: #3e3e3e;
border-radius: var(--border-radius);
}
.color-option {
width: 12vmin;
height: 12vmin;
border-radius: 50%;
cursor: pointer;
border: 0.5vmin solid white;
transition: transform 0.2s, box-shadow 0.2s;
}
.color-option:hover {
transform: scale(1.1);
box-shadow: 0 0 2vmin #fff;
}
.color-option[data-color="red"] { background-color: #ff5555; }
.color-option[data-color="yellow"] { background-color: #ffaa00; }
.color-option[data-color="green"] { background-color: #55aa55; }
.color-option[data-color="blue"] { background-color: #5555ff; }
.game-over-modal {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 100;
display: none;
flex-direction: column;
justify-content: center;
align-items: center;
color: white;
font-size: 5vmin;
text-align: center;
}
.game-over-modal h2 { margin: 0; }
.game-over-modal button {
margin-top: 2vmin;
padding: 1vmin 2vmin;
font-size: 2vmin;
cursor: pointer;
}
</style>
</head>
<body>
<div id="game-window" class="game-window">
<div class="player-hand" id="ai-player-1-hand"></div>
<div class="center-area">
<button id="rules-btn" class="rules-btn"></button>
<br>
<div id="game-status" class="game-status"></div>
<div class="deck-pile-container">
<div class="card back" id="deck"></div>
<div class="card" id="discard-pile"></div>
</div>
</div>
<div class="player-hand" id="ai-player-2-hand"></div>
<div class="player-hand human-player" id="human-player-hand"></div>
<div id="game-over-modal" class="game-over-modal">
<h2 id="winner-message"></h2>
<button id="play-again-btn">Spill igjen</button>
</div>
</div>
<div id="rules-modal" class="modal-overlay">
<div class="modal-content">
<span id="close-btn" class="close-btn">×</span>
<h2 id="rules-title"></h2>
<p><strong id="rules-goal-title"></strong> <span id="rules-goal-text"></span></p>
<h3 id="rules-how-to-title"></h3>
<p id="rules-how-to-text"></p>
<h3 id="rules-special-title"></h3>
<ul id="rules-special-list">
<li id="rules-skip"></li>
<li id="rules-reverse"></li>
<li id="rules-draw2"></li>
<li id="rules-wild"></li>
<li id="rules-wild4"></li>
</ul>
</div>
</div>
<div id="color-picker-modal" class="modal-overlay">
<div class="color-picker">
<div class="color-option" data-color="red"></div>
<div class="color-option" data-color="yellow"></div>
<div class="color-option" data-color="green"></div>
<div class="color-option" data-color="blue"></div>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const lang = {
regler: "Regler",
velkommen: "Velkommen til UNO!",
dinTur: "Din tur.",
spillerTur: "Spiller X sin tur.",
aiSpillerKort: "Spiller X legger et kort...",
aiTrekkerKort: "Spiller X trekker et kort.",
aiSpilteTrukket: "Spiller X spilte kortet de trakk!",
aiKunneIkkeSpille: "Spiller X kunne ikke spille.",
aiValgteFarge: "Spiller X valgte fargen Y.",
duTrekkerKort: "Du trekker et kort...",
duSpilteTrukket: "Du trakk et spillbart kort og spilte det!",
kortKanIkkeSpilles: "Kortet kan ikke spilles. Neste tur.",
ugyldigTrekk: "Ugyldig trekk. Kortet må matche farge eller symbol.",
harSpillbartKort: "Du har et spillbart kort. Du kan ikke trekke.",
bunkenErTom: "Kortstokken er tom!",
stokkerBunke: "Stokker brukte kort og lager ny bunke.",
spillerHoppetOver: "Spiller X ble hoppet over!",
retningReversert: "Spillretningen er snudd!",
spillerTrekkerTo: "Spiller X må trekke 2 kort!",
spillerTrekkerFire: "Spiller X må trekke 4 kort!",
spillerHarUno: "Spiller X har UNO!",
duHarUno: "Du har UNO!",
spillerVant: "Spiller X vant spillet! Gratulerer! 🏆",
duVant: "Du vant spillet! Gratulerer! 🏆",
spillStarter: "Spillet starter...",
spillStartet: "Spillet har startet!",
startMedHoppOver: "Spillet starter med Hopp Over! Spiller X sin tur.",
startMedVend: "Spillet starter med Vend! Spiller X sin tur.",
startMedTrekk2: "Spillet starter med Trekk 2! Spiller X må trekke.",
reglerTittel: "UNO-Regler",
reglerMaalTittel: "Mål:",
reglerMaalTekst: "Vær den første spilleren som blir kvitt alle kortene dine.",
reglerSlikSpillerDuTittel: "Slik spiller du",
reglerSlikSpillerDuTekst: "Du kan spille et kort fra hånden din hvis det matcher fargen, tallet eller symbolet til kortet på toppen av bunken. Hvis du ikke kan spille, må du trekke et kort fra kortstokken. Lykke til!",
reglerSpesialkortTittel: "Spesialkort",
reglerHoppOver: "<strong>Hopp over (🚫):</strong> Neste spiller mister sin tur.",
reglerVend: "<strong>Vend (🔄):</strong> Spillretningen reverseres.",
reglerTrekk2: "<strong>Trekk To (+2):</strong> Neste spiller trekker to kort og mister sin tur.",
reglerVri: "<strong>Vri (W):</strong> Kan spilles på hvilket som helst kort. Spilleren som legger det ned, velger neste farge.",
reglerVri4: "<strong>Vri + Trekk Fire (W+4):</strong> Kan kun spilles hvis du ikke har andre spillbare kort. Spilleren velger neste farge, og neste spiller trekker fire kort og mister sin tur.",
farger: { 'red': 'Rød', 'yellow': 'Gul', 'green': 'Grønn', 'blue': 'Blå' }
};
const SUITS = ['red', 'yellow', 'green', 'blue'];
const VALUES = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
const WILD_VALUES = ['wild', 'wild4'];
const NUM_PLAYERS = 3;
const HUMAN_PLAYER_INDEX = 0;
let deck = [];
let players = [];
let discardPile = [];
let currentPlayerIndex = 0;
let gameDirection = 1;
let isProcessingTurn = false;
const humanPlayerHandEl = document.getElementById('human-player-hand');
const aiPlayerHandElements = [
document.getElementById('ai-player-1-hand'),
document.getElementById('ai-player-2-hand')
];
const discardPileEl = document.getElementById('discard-pile');
const deckEl = document.getElementById('deck');
const gameStatusEl = document.getElementById('game-status');
const rulesBtn = document.getElementById('rules-btn');
const rulesModal = document.getElementById('rules-modal');
const closeBtn = document.getElementById('close-btn');
const colorPickerModal = document.getElementById('color-picker-modal');
const gameOverModal = document.getElementById('game-over-modal');
const winnerMessageEl = document.getElementById('winner-message');
const playAgainBtn = document.getElementById('play-again-btn');
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
function updateStaticUIText() {
document.title = "UNO Kortspill";
rulesBtn.textContent = lang.regler;
gameStatusEl.textContent = lang.velkommen;
document.getElementById('rules-title').textContent = lang.reglerTittel;
document.getElementById('rules-goal-title').textContent = lang.reglerMaalTittel;
document.getElementById('rules-goal-text').textContent = lang.reglerMaalTekst;
document.getElementById('rules-how-to-title').textContent = lang.reglerSlikSpillerDuTittel;
document.getElementById('rules-how-to-text').textContent = lang.reglerSlikSpillerDuTekst;
document.getElementById('rules-special-title').textContent = lang.reglerSpesialkortTittel;
document.getElementById('rules-skip').innerHTML = lang.reglerHoppOver;
document.getElementById('rules-reverse').innerHTML = lang.reglerVend;
document.getElementById('rules-draw2').innerHTML = lang.reglerTrekk2;
document.getElementById('rules-wild').innerHTML = lang.reglerVri;
document.getElementById('rules-wild4').innerHTML = lang.reglerVri4;
}
function getCardDisplayValue(card) {
switch (card.value) {
case 'skip': return '🚫';
case 'reverse': return '🔄';
case 'draw2': return '+2';
case 'wild': return 'W';
case 'wild4': return 'W+4';
default: return card.value.toUpperCase();
}
}
function isValidPlay(card, topCard) {
if (!topCard) return false;
if (card.suit === 'wild') {
if (card.value === 'wild4') {
const playerHand = players[currentPlayerIndex];
const hasMatchingColorCard = playerHand.some(c => c.suit !== 'wild' && c.suit === topCard.suit);
return !hasMatchingColorCard;
}
return true;
}
return card.suit === topCard.suit || card.value === topCard.value;
}
function createDeck() {
const newDeck = [];
SUITS.forEach(suit => {
VALUES.forEach(value => {
newDeck.push({ suit, value, originalSuit: suit });
if (value !== '0') {
newDeck.push({ suit, value, originalSuit: suit });
}
});
});
WILD_VALUES.forEach(value => {
for (let i = 0; i < 4; i++) {
newDeck.push({ suit: 'wild', value, originalSuit: 'wild' });
}
});
return newDeck;
}
function shuffleDeck(deck) {
for (let i = deck.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[deck[i], deck[j]] = [deck[j], deck[i]];
}
}
function renderCard(card) {
const cardElement = document.createElement('div');
cardElement.className = 'card';
cardElement.dataset.color = card.suit;
const displayValue = getCardDisplayValue(card);
cardElement.innerHTML = `<div class="inner-symbol">${displayValue}</div>`;
return cardElement;
}
function updateAllUI() {
renderPlayerHands();
renderDiscardPile();
highlightPlayableCards();
updateActivePlayerIndicator();
}
function renderPlayerHands() {
humanPlayerHandEl.innerHTML = '';
players[HUMAN_PLAYER_INDEX].forEach(card => {
const cardElement = renderCard(card);
cardElement.addEventListener('click', () => onPlayerCardClick(card));
humanPlayerHandEl.appendChild(cardElement);
});
for (let i = 1; i < NUM_PLAYERS; i++) {
const aiHandEl = aiPlayerHandElements[i - 1];
aiHandEl.innerHTML = '';
players[i].forEach(() => {
const cardElement = document.createElement('div');
cardElement.className = 'card back';
aiHandEl.appendChild(cardElement);
});
}
}
function renderDiscardPile() {
discardPileEl.innerHTML = '';
const topCard = discardPile[discardPile.length - 1];
if (topCard) {
discardPileEl.className = 'card';
discardPileEl.dataset.color = topCard.suit;
discardPileEl.innerHTML = `<div class="inner-symbol">${getCardDisplayValue(topCard)}</div>`;
} else {
discardPileEl.className = 'card';
}
}
function highlightPlayableCards() {
const topCard = discardPile[discardPile.length - 1];
if (!topCard) return;
const humanCards = humanPlayerHandEl.children;
for (let i = 0; i < humanCards.length; i++) {
const card = players[HUMAN_PLAYER_INDEX][i];
const cardEl = humanCards[i];
if (currentPlayerIndex === HUMAN_PLAYER_INDEX && isValidPlay(card, topCard)) {
cardEl.classList.add('playable');
cardEl.classList.remove('unplayable');
} else {
cardEl.classList.add('unplayable');
cardEl.classList.remove('playable');
}
}
if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
deckEl.classList.add('can-draw');
} else {
deckEl.classList.remove('can-draw');
}
}
function updateActivePlayerIndicator() {
humanPlayerHandEl.classList.remove('active-player-indicator');
aiPlayerHandElements.forEach(el => el.classList.remove('active-player-indicator'));
if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
humanPlayerHandEl.classList.add('active-player-indicator');
} else {
aiPlayerHandElements[currentPlayerIndex - 1].classList.add('active-player-indicator');
}
}
function updateStatus(message, vars = {}) {
let finalMessage = message;
if (vars.playerIndex !== undefined) {
finalMessage = finalMessage.replace('X', vars.playerIndex + 1);
}
if (vars.color) {
finalMessage = finalMessage.replace('Y', lang.farger[vars.color]);
}
gameStatusEl.textContent = finalMessage;
}
async function onPlayerCardClick(card) {
if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;
const topCard = discardPile[discardPile.length - 1];
if (isValidPlay(card, topCard)) {
isProcessingTurn = true;
await playCard(card, HUMAN_PLAYER_INDEX);
} else {
updateStatus(lang.ugyldigTrekk);
await sleep(2000);
updateStatus(lang.dinTur);
}
}
async function onDeckClick() {
if (isProcessingTurn || currentPlayerIndex !== HUMAN_PLAYER_INDEX) return;
const topCard = discardPile[discardPile.length - 1];
const hasPlayable = players[HUMAN_PLAYER_INDEX].some(card => isValidPlay(card, topCard));
if (hasPlayable) {
updateStatus(lang.harSpillbartKort);
return;
}
isProcessingTurn = true;
updateStatus(lang.duTrekkerKort);
await sleep(500);
const drawnCard = drawCard(HUMAN_PLAYER_INDEX);
updateAllUI();
await sleep(800);
if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
updateStatus(lang.duSpilteTrukket);
await sleep(800);
await playCard(drawnCard, HUMAN_PLAYER_INDEX);
} else {
updateStatus(lang.kortKanIkkeSpilles);
await sleep(800);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
endTurn();
}
}
function drawCard(playerIndex) {
if (deck.length === 0) {
if (discardPile.length <= 1) {
updateStatus(lang.bunkenErTom);
return null;
}
const topCard = discardPile.pop();
deck = discardPile.map(c => ({ ...c, suit: c.originalSuit }));
discardPile = [topCard];
shuffleDeck(deck);
updateStatus(lang.stokkerBunke);
}
const card = deck.pop();
if (card) {
players[playerIndex].push(card);
}
return card;
}
async function playCard(card, playerIndex) {
const cardIndex = players[playerIndex].findIndex(c => c === card);
if (cardIndex === -1) {
isProcessingTurn = false;
return;
}
const [playedCard] = players[playerIndex].splice(cardIndex, 1);
if (playedCard.value === 'wild' || playedCard.value === 'wild4') {
const chosenColor = await handleWildCard(playerIndex);
playedCard.suit = chosenColor;
if (playerIndex !== HUMAN_PLAYER_INDEX) {
updateStatus(lang.aiValgteFarge, { playerIndex, color: chosenColor });
await sleep(800);
}
}
discardPile.push(playedCard);
if (checkWinCondition(playerIndex)) return;
await handleSpecialCardEffects(playedCard, playerIndex);
}
async function handleSpecialCardEffects(card, playerIndex) {
let nextPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
let turnAdvanced = false;
updateAllUI();
await sleep(500);
switch (card.value) {
case 'skip':
updateStatus(lang.spillerHoppetOver, { playerIndex: nextPlayerIndex });
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
case 'reverse':
gameDirection *= -1;
updateStatus(lang.retningReversert);
break;
case 'draw2':
updateStatus(lang.spillerTrekkerTo, { playerIndex: nextPlayerIndex });
await sleep(500);
drawCard(nextPlayerIndex);
drawCard(nextPlayerIndex);
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
case 'wild4':
updateStatus(lang.spillerTrekkerFire, { playerIndex: nextPlayerIndex });
await sleep(500);
for (let i = 0; i < 4; i++) drawCard(nextPlayerIndex);
currentPlayerIndex = (nextPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
turnAdvanced = true;
break;
}
if (!turnAdvanced) {
currentPlayerIndex = (playerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
}
await sleep(800);
endTurn();
}
function endTurn() {
updateAllUI();
if (currentPlayerIndex === HUMAN_PLAYER_INDEX) {
updateStatus(lang.dinTur);
isProcessingTurn = false;
} else {
updateStatus(lang.spillerTur, { playerIndex: currentPlayerIndex });
isProcessingTurn = true;
setTimeout(aiTurn, 1500);
}
}
function checkWinCondition(playerIndex) {
if (players[playerIndex].length === 0) {
const message = playerIndex === HUMAN_PLAYER_INDEX ? lang.duVant : lang.spillerVant.replace('X', playerIndex + 1);
winnerMessageEl.textContent = message;
gameOverModal.style.display = 'flex';
return true;
}
if (players[playerIndex].length === 1) {
const message = playerIndex === HUMAN_PLAYER_INDEX ? lang.duHarUno : lang.spillerHarUno.replace('X', playerIndex + 1);
updateStatus(message);
}
return false;
}
function handleWildCard(playerIndex) {
if (playerIndex === HUMAN_PLAYER_INDEX) {
return new Promise(resolve => {
colorPickerModal.style.display = 'flex';
const onColorSelect = (e) => {
const chosenColor = e.target.dataset.color;
if (chosenColor) {
colorPickerModal.style.display = 'none';
colorPickerModal.removeEventListener('click', onColorSelect);
resolve(chosenColor);
}
};
colorPickerModal.addEventListener('click', onColorSelect);
});
} else {
const colorCounts = SUITS.reduce((acc, color) => ({ ...acc, [color]: 0 }), {});
players[playerIndex].forEach(c => {
if (c.suit !== 'wild') colorCounts[c.suit]++;
});
let maxCount = -1;
let dominantColor = SUITS[Math.floor(Math.random() * SUITS.length)];
for (const color in colorCounts) {
if (colorCounts[color] > maxCount) {
maxCount = colorCounts[color];
dominantColor = color;
}
}
return Promise.resolve(dominantColor);
}
}
async function aiTurn() {
const aiIndex = currentPlayerIndex;
const topCard = discardPile[discardPile.length - 1];
await sleep(500);
let playableCards = players[aiIndex].filter(card => isValidPlay(card, topCard));
if (playableCards.length > 0) {
let cardToPlay =
playableCards.find(c => ['wild4', 'draw2', 'skip', 'reverse'].includes(c.value)) ||
playableCards[Math.floor(Math.random() * playableCards.length)];
updateStatus(lang.aiSpillerKort, { playerIndex: aiIndex });
await sleep(800);
await playCard(cardToPlay, aiIndex);
} else {
updateStatus(lang.aiTrekkerKort, { playerIndex: aiIndex });
await sleep(800);
const drawnCard = drawCard(aiIndex);
updateAllUI();
await sleep(500);
if (drawnCard && isValidPlay(drawnCard, discardPile[discardPile.length - 1])) {
updateStatus(lang.aiSpilteTrukket, { playerIndex: aiIndex });
await sleep(800);
await playCard(drawnCard, aiIndex);
} else {
updateStatus(lang.aiKunneIkkeSpille, { playerIndex: aiIndex });
await sleep(800);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
endTurn();
}
}
}
async function handleFirstCard(card) {
discardPile.push(card);
updateAllUI();
await sleep(500);
switch (card.value) {
case 'skip':
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
updateStatus(lang.startMedHoppOver, { playerIndex: currentPlayerIndex });
break;
case 'reverse':
gameDirection *= -1;
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
updateStatus(lang.startMedVend, { playerIndex: currentPlayerIndex });
break;
case 'draw2':
updateStatus(lang.startMedTrekk2, { playerIndex: currentPlayerIndex });
await sleep(500);
drawCard(currentPlayerIndex);
drawCard(currentPlayerIndex);
currentPlayerIndex = (currentPlayerIndex + gameDirection + NUM_PLAYERS) % NUM_PLAYERS;
break;
}
await sleep(800);
endTurn();
}
async function startGame() {
gameOverModal.style.display = 'none';
deck = createDeck();
shuffleDeck(deck);
players = Array(NUM_PLAYERS).fill(0).map(() => []);
discardPile = [];
currentPlayerIndex = 0;
gameDirection = 1;
isProcessingTurn = true;
for (let i = 0; i < 7; i++) {
for (let j = 0; j < NUM_PLAYERS; j++) {
players[j].push(deck.pop());
}
}
let firstCard = deck.pop();
const invalidStartCards = ['skip', 'reverse', 'draw2', 'wild', 'wild4'];
while (invalidStartCards.includes(firstCard.value)) {
deck.push(firstCard);
shuffleDeck(deck);
firstCard = deck.pop();
}
updateAllUI();
updateStatus(lang.spillStarter);
await sleep(1000);
await handleFirstCard(firstCard);
}
rulesBtn.addEventListener('click', () => { rulesModal.style.display = 'flex'; });
closeBtn.addEventListener('click', () => { rulesModal.style.display = 'none'; });
playAgainBtn.addEventListener('click', startGame);
window.addEventListener('click', (event) => {
if (event.target === rulesModal) {
rulesModal.style.display = 'none';
}
});
deckEl.addEventListener('click', onDeckClick);
updateStaticUIText();
startGame();
});
</script>
</body>
</html>
